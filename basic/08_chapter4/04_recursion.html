<!-- Recursion [재귀(적 용법)]

1. 함수가 함수안에서 자신을 다시 호출하는 것을 Recursion이라고 한다.

### Infinite Loop!!!      <== 브라우저가 다운된다!!!
var foo = function () {
  foo();
};


### Example01 : 카운트 다운 함수
// 일반 버전
var countdown = function () {
  for (let i = 10; i >= 0; i--) {
    console.log(i);
  }
  console.log('Fire!!!');
};
countdown();

// 재귀 버전 : 무한 루프를 제어하기 위해 반드시 "종료조건"이 있어야 한다. 'return'명령을 이용.
var recursiveCountdown = function (n) {
  if (n < 0) {
    console.log('Fire!!!');
    return;
  }
  console.log(n);
  recursiveCountdown(n-1);
};
recursiveCountdown(10);


2. '재귀'를 사용하는 이유
1) 재귀를 사용하면 쉽게 풀리는 문제들이 많다.
2) 알고리즘에서 list, tree, squence 관련 문제들은 재귀로 해결하는 것이 편하다.
3) 일반함수가 재귀함수보다 높은 성능을 보인다.
4) 모든 재귀함수 알고리즘은 일반함수 알고리즘으로 바꿀 수 있다. 왜?
  - 재귀 없이 구현하면 성능이 좋아지고(빨라지고),
  - 재귀를 사용하면 프로그래머의 능력(코드의 효율)이 향상된다.


### Example02 : a부터 b까지 정수를 더해서 리턴해 주는 함수
// 일반 버전
var addNumbers = function (a, b) {
  var result = 0;
  for (let i = 0; i <= (b-a); i++) {
    result += a + i;
  }
  return result;
};
addNumbers(1, 10);

// 재귀 버전
var recursiveAddNumbers = function (a, b) {
  if (a === b) {
    return b;
  }
  return (a + recursiveAddNumbers(a+1, b));
};
recursiveAddNumbers(1, 10);


### Example03 : 1부터 n까지 정수를 곱해서 리턴해 주는 함수(팩토리얼)
//일반 버전
var factorial = function (n) {
  var result = 1;
  for (let i = 1; i < n; i++) {
    result *= i + 1;
  }
  return result;
};
factorial(5);

// 재귀 버전
var recursiveFactorial = function (n) {
  if (n === 1) {
    return 1;
  }
  return (n * recursiveFactorial(n-1));
};
factorial(5);


### Example04 : Fibonacci Sequence
// 일반 버젼 : Dynamic Programming, Memorization Programming
var fibonacci = function (n) {
  var result = [];
  for (let i = 0; i < n+1; i++) {
    if (i === 0) {
      result[i] = 0;
    } else if (i === 1) {
      result[i] = 1;
    } else {
      result[i] = result[i-2] + result[i-1];
    }
  }
  return result[n];
};
fibonacci(10);
fibonacci(100);
fibonacci(1000);
fibonacci(10000);        <== 재귀버전보다 월등하게 성능이 좋다!!!

// 재귀 버전
var recursiveFibonacci = function (n) {
  if (n === 0) {
    return 0;
  } else if (n === 1) {
    return 1;
  } else {
    return (recursiveFibonacci(n-2) + recursiveFibonacci(n-1));
  }
};
recursiveFibonacci(10);
recursiveFibonacci(20);
recursiveFibonacci(31);
recursiveFibonacci(32);
recursiveFibonacci(33);  <== 구하지 못한다!!!

 -->
